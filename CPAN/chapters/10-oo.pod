
=head0 Modern Perl OO

X<Moo>X<Module, Moo> X<Moose>X<Module, Moose> X<Mouse>X<Module, Mouse>
X<OO Programming> Perl always suffered from the lack of a rigid object
oriented system. Although blessed references did the trick for years,
developers felt sorry they did not have support for some common OO
features, like interfaces (or roles), multiple inheritance and
encapsulation.

A few years ago C<Moose> appeared. At first it was quite slow and its
usage was discouraged. Fortunately, in the last years, C<Moose> became
quite fast and includes a lot of relevant and useful features.

Nevertheless, C<Moose> is still quite slow for applications that need
to start every time. That is, in applications like CGI scripts, that
are parsed and run every time a request is made, the overhead of
loading C<Moose> is not acceptable.

To solve this problem some developers started C<Mouse>, a smaller
implementation that does not include all C<Moose> functionalities, but
only the more relevant ones. It maintains the API compatible with
C<Moose>, making it easier to switch whenever needed.

Another implementation, named C<Moo>, claims to be yet smaller and
faster than C<Mouse>, although it does not have much users yet.

Given that all these modules share the basic syntax, this chapter
structure will be slightly different from the next ones. First, we
will present C<Moo>, then, what C<Mouse> offers over C<Moo>, and
finally, what C<Moose> offers more than C<Mouse>. This approach will
make this chapter smaller and help the reader when choosing one
implementation.

=head1 Moo

X<Moo>X<Module, Moo>

=begin CPANinfo

B<Version:> 0.009008

B<CPAN:> L<http://search.cpan.org/dist/Moo>

=end CPANinfo

C<Moo> uses the usual approach to define objects: use packages (the
Perl equivalent to what we are used to call classes).

=head2 *Attributes

Follows a simple example of a I<Person> object with two attributes,
I<name> and I<phone>. The first is a read only attribute (you can't
change the person name after initializing the object) while the second
has read/write permissions. This information is used by C<Moo> to
define whether to create accessors that are able to set and get
values, or just get values. The I<required> option means that every
time a I<Person> object is created a name must be provided.

=begin Perl

 package Person;
 use Moo;

 has name  => ( is => 'ro',  required => 1 );
 has phone => ( is => 'rw' );
 1;

=end Perl

Note that the fat arrow is equivalent to a comma, and the parenthesis
are not needed. The first attribute could be defined as:

  has "name", "is", "ro", "required", 1;

but its legibility is not the same. Therefore we will stick to the
usage of the fat arrow together with parenthesis or indentation to
group attribute options.

This object usage is similar to the usage of standard blessed
reference objects. C<Moo> creates automatically the constructor and
accessors.

=begin Perl

 use Person;

 my $person = Person->new(name => 'John');
 print $person->name;

 $person->phone("93453423");
 print $person->phone;

=end Perl

Unlike the next two alternatives, C<Moo> doesn't have a type
system. If you need to guarantee that an attribute keeps a specific
type of data, you need to validate it yourself. That is done adding a
code reference. The next example is a redefinition of the attribute
C<phone> forcing a nine digits string:

=begin Perl

 has phone =>
      is  => 'rw',
      isa => sub {
         die "Need a nine digit string!" unless $_[0] =~ /^\d{9}$/
      };

=end Perl

Attributes can have default values. This is specified using the
C<default> option. It takes a code reference that receives the object,
and should return the new value. Note that you should not rely on
other attributes for this initialization as there is no guarantee that
they were already populated (for that use I<lazy> attributes). As an
example, you can create an attribute C<sex> and define it
automatically to I<female> if not specified.

=begin Perl

 has sex =>
      is => 'ro',
      default => sub { return 'female' };

=end Perl

If the default value need to be computed based on some attributes, or
the task of computing it is time or CPU expensive, you can define the
attribute as I<lazy> (set it to a true value). This way the value will
only be computed when it is first accessed.

When some code should run after a specific attribute is set a
C<trigger> should be used. It is just a code reference that will be
called over the object, with the new value as argument. For instance,
when a phone number is registered, call some method to send a SMS to
the new number acknowledging the change:

=begin Perl

 has phone =>
      is  => 'rw',
      isa => sub {
         die "Need a nine digit string!" unless $_[0] =~ /^\d{9}$/
      },
      trigger => sub {
         send_sms( to => $_[1],
                   msg => "Phone number correctly updated.")
      };

=end Perl

=head2 *Inheritance and Roles

The usual inheritance between classes is also possible. In fact,
C<Moo> supports multiple super-classes. They are defined with the
C<extends> methodN<< Calling C<extends> more than once will B<replace>
the super-classes, not add a new. >>:

=begin Perl

 package Student;
 extends 'Person';

 has final_grade => ( is => 'rw' );
 1;

=end Perl

One of C<Moo> premises to remain small is not support to
C<super>. This means it is not that easy to override
methods. Nevertheless it can be done using method modifiers (see
A<moomodifiers>).

If the code being extended (the super-class) will never be
instantiated, probably you want to use I<roles>. I<Roles> can be seen
as the Java interfaces, or as a specific set of methods that implement
a specific functionality. C<Moo> roles are defined using the
C<Role::Tiny> X<Module, Role::Tiny> X<Role::Tiny> module.

The definition of a role is simple. Create a brand new package, use
C<Role::Tiny>, and write all the code the role should implement. As a
simple example consider a role that dumps the object to the standard
error (useful for debugging):

=begin Perl

 package Dumper::Role;
 use Role::Tiny;
 use Data::Dumper;

 sub dump {
   my $self = shift;
   print STDERR Dumper($self);
 }
 1;

=end Perl

Now, you can switch from role to role using C<with>. For simplicity
C<Moo> activates only one role at a time. Our main program now can
say:

=begin Perl

 use Moo;
 use Person;

 my $person = Person->new(name => 'Mary', phone => '987654321');

 with 'Dumper::Role';
 $person->dump;

=end Perl

Note that the C<dump> method is not implemented in the I<Person>
class, but rather in the role. This means you can activate this role
for any object.

=head2 *Method Modifiers

Z<moomodifiers>X<Class::Method::Modifiers>X<Module, Class::Method::Modifiers>

The method modifiers here described are not really part of the object
system, but are available in C<Moo> as a workaround for some
limitations, like the lack of access to C<super>. They are implemented
though the C<Class::Method::Modifiers> module that can be used
independently.

These methods can be viewed as hooks that are called before and/or
after some methods are called. As an example, we want to add a line of
debug before dumping a person. Therefore, in the C<Person.pm> file we
will switch to the role that implements C<dump>, and activate a
modifier, asking to run some code before the actual method:

=begin Perl

   with 'Dumper::Role';
   before dump => sub { print STDERR "Dumping a Person!\n" };

=end Perl

The method will receive the same arguments as the method
itself. Return values are ignored, but you can change C<@_> directly,
and the changed values will be received by the original method.

C<after> works in the same way, and receives C<@_> as the original
method received. This means that if the original method changes the
values, C<after> will receive them modified.

Finally, there is C<around>, that is called instead of the original
method. This means that the code run should call the original method
(if needed, or just ignore it). For that to be possible, the code you
define will receive as first argument the method that is being
replaced. Suppose you have a role that implements a method similar
with the described above, to send a SMS message, but that uses the
phone number stored in the object, but you need to add a prefix to the
number ("+0", for instance) before calling it, and that you need to
get the result (a boolean) and transform it into a string "OK" or
"NOK":

=begin Perl

  with 'SMS::Role';
  around send_sms => sub { 
           my ($orig, $self, $message) = @_;

           my $number = $self->phone; # save number
           $self->phone("+0$number");
           my $ok = $self->$orig($message);
           $self->phone($number); # revert number
           return $ok ? "OK" : "NOK";
  }

=end Perl

=head1 Mouse

X<Mouse>X<Module, Mouse>

=begin CPANinfo

B<Version:> 0.93

B<CPAN:> L<http://search.cpan.org/dist/Mouse>

=end CPANinfo

As mentioned in this chapter introduction C<Mouse> aims to be a subset
implementation of C<Moose>, with fewer dependencies, with an optional
XS back-end (meaning you will not necessarily need a C<< C >>
compiler) and reducing the C<Moose> startup time.

=head2 *Attributes

The syntax for defining attributes is the same C<Moo> uses. The first
main difference is that C<Mouse> introduces a type system, instead of
the code reference that C<Moo> uses to check values types. Some of
C<Mouse> data types are: C<Any> to store anything, C<Bool> for boolean
values, C<Str> to store a string or a number, just like Perl scalar
variables handle them, C<Num> for numbers, including reals, C<Int> for
integer numbers, C<ClassName> when you are storing a object class
name, C<Ref> for any kind of reference, C<ScalarRef> for a reference
to a scalar, C<ArrayRef> to a reference to an array, C<HashRef> to a
reference to hashes, C<RegexpRef> for regular expressions, etc. You
can get a detailed list and their relationship in the
C<Mouse::Util::TypeConstraints>. This
module also allows you to define sub-types based on the built-in
types. Finally, if you define a type name that is unknown, C<Mouse>
will interpret it as the name of a class that should be checked using
C<ref>.

The C<default> value for the attribute can be set like with C<Moo>
using a code reference, but it is also possible to specify directly a
value. But be caution about references.

Our I<Person> class is written with C<Mouse> as follows:

=begin Perl

 package Person;
 use Mouse;

 has name  => 
      is => 'ro', required => 1,  isa => 'Str';
 has phone =>
      is => 'rw',
      isa => 'Str',
      trigger => sub {
         send_sms( to => $_[1],
                   msg => "Phone number correctly updated.")
      };
 has sex =>
      is => 'ro', default => "female";
 1;

=end Perl

There are some relevant differences in this code. First, we are not
requiring the phone number to have nine digits. Check
A<typeconstraints> for a solution through subtypes. The other
difference is more subtle: the C<trigger> method receives the same
first two arguments as the C<Moo> example, but a third argument is
also supplied: the value before the attribution takes place.

=head2 *Inheritance and Roles

Inheritance in C<Mouse> is also handled using the C<extends>
method. 

Roles (handled by C<Mouse::Role> X<Mouse::Role> X<Module,
Mouse::Role>), ...

=head2 *Method Modifiers

C<Mouse> supports C<before>, C<after> and C<around>, just like C<Moo>
The main difference is that they accept a regular expression, and will
apply the modifier to all the methods that match the expression.

=head2 *Type Constraints

Z<typeconstraints> X<Module,
Mouse::Util::TypeConstraints> X<Mouse::Util::TypeConstraints>

=head2 *Meta-Model

=head1 Moose

X<Moose>X<Module, Moose>

=begin CPANinfo

B<Version:> 2.0007

B<CPAN:> L<http://search.cpan.org/dist/Moose>

=end CPANinfo

=cut

## Local Variables:
##  ispell-local-dictionary: "english"
##  mode: flyspell
## End:

